"""
File for the Telecom subsystem implementation.

This module defines the Telecom class, responsible for managing the spacecraft's communication operations.

Classes:
    Telecom: Represents the Telecom subsystem.
"""

from astropy import units as u
from astropy.time import TimeDelta
from astropy.units import Quantity
import numpy as np

from digital_twin.spacecraft import SubSystem
from digital_twin.spacecraft.payload import Payload
from digital_twin.utils import get_astropy_unit_time


class Telecom(SubSystem):
    """
    Represent the Telecom subsystem for spacecraft communications (UHF anf XBAND).

    Attributes:
        name (str): The name of the subsystem.
        consumption_mean_uhf (dict[int, Quantity["power"]]): Mean power consumption of UHF system for different operating modes.
        consumption_mean_x_band (dict[int, Quantity["power"]]): Mean power consumption of X-BAND system for different operating modes.
        com_max_duration (Quantity["time"]): Maximum allowed communication duration.
        x_band_rate (Quantity["bandwidth"]): Data rate for transmiting X-band scientific data.
        uhf_rate (Quantity["bandwidth"]): Data rate for UHF communication (housekeeping data).
        t_max_no_com (Quantity["time"]): Maximum time allowed without communication.
        t_no_com (Quantity["time"]): Time without communication since the last contact.
        com_duration (Quantity["time"]): Duration of the current communication session since it started.
        is_communicating (bool): Indicates whether the system is currently in communication with a ground station.
        alternating (bool): Prevents alternating between 2 communication modes (UHF and XBAND) during a visibility window.
        safe_flag (bool): Indicates whether the subsystem is in safe mode.
        safe_flag_reason (int): Reason for the safe mode flag (e.g., no communication for too long).
        safe_flag_duration_left_dict (dict[int, Quantity["time"]]): Duration left for safe mode resolution for each safe flag raised by a command from Ground Station.
        safe_flag_duration_left (Optional[Quantity["time"]]): Remaining duration before safe mode is resolved (if safe flag was generated by a command from Ground Station).
        is_visible (bool): Indicates whether the spacecraft is within a visibility window.
        vis_window_count (int): Counter for visibility window occurrences.
        vis_window_triggered (int): The visibility window number that triggered the safe mode.
    """

    def __init__(self, params: dict, init_operating_mode: int) -> None:
        print("Initializing Telecom subsystem... ")
        self.name = "Telecom"

        super(Telecom, self).__init__()

        self.consumption_mean_uhf = {
            int(k): v * u.W for k, v in params["consumption_uhf"].items()
        }
        self.consumption_mean_x_band = {
            int(k): v * u.W for k, v in params["consumption_x_band"].items()
        }
        com_unit = get_astropy_unit_time(params["communication_max_duration_unit"])
        self.com_max_duration = (params["communication_max_duration"] * com_unit).to(
            u.s
        )
        self.x_band_rate = float(params["x_band_rate"]) * (u.Mbit / u.s)
        self.uhf_rate = float(params["uhf_rate"]) * (u.Mbit / u.s)

        t_com_unit = get_astropy_unit_time(
            params["max_time_without_communication_unit"]
        )
        self.t_max_no_com = (params["max_time_without_communication"] * t_com_unit).to(
            u.s
        )  # Maximum time allowed without communicating to ground station
        self.t_no_com = float(params["init_time_no_com"]) * u.s

        # Variables to track if communication is occuring and since how much time (UHF_COM)
        self.com_duration = float(params["init_com_duration"]) * u.s
        self.is_communicating = (
            False if params["init_is_communicating"] == "false" else True
        )

        self.alternating = (
            False if params["init_is_alternating"] == "false" else True
        )  # Boolean variable which prevents from alternating between x-band-comm and uhf-comm mode during visibility window

        # INITIALIZATION OF SAFE FLAG
        self.safe_flag = (
            False if params["init_safe_flag"] == "false" else True
        )  # Default should be False
        self.safe_flag_reason = int(
            params["init_safe_flag_reason"]
        )  # Default should be -1
        self.safe_flag_duration_left_dict = {}

        self.safe_flag_duration_left = (
            None
            if params["init_safe_flag_duration_left"] == "none"
            else float(params["init_safe_flag_duration_left"]) * u.s
        )
        # If a safe mode is active at initialization and not stopped by a duration, need to have a condition to resolve it
        if self.safe_flag and self.safe_flag_duration_left == "none":
            self.uplink_safe_mode = {int(params["uplink_safe_mode"]): False}
        else:
            # Is used to store uplink commands from GS to trigger/resolve safe mode
            self.uplink_safe_mode = {}

        self.is_visible = (
            False if params["init_is_visible"] == "false" else True
        )  # Variable to track visibility windows

        self.vis_window_count = 0
        self.vis_window_triggered = -1

    def handshake(self) -> bool:
        # Dummy implementation for now
        return True

    # Function used by the switch tree agorithm
    def can_downlink(self) -> bool:
        """Determine if downlinking can proceed during the current communication mode."""
        if (
            self.alternating
        ):  # Prevents from alternating between uhf-comm and x-band-comm endlessly during visibility window
            return False
        else:
            return True

    # Function used by the switch tree agorithm
    def com_finished(self) -> bool:
        """Check if the communication session has finished (using com_max_duration)."""
        if not self.is_communicating:
            return True
        # Stop the communication when maximum time is reached
        else:
            if self.com_duration >= self.com_max_duration:
                return True
            return False

    def update(
        self,
        old_mode: int,
        new_mode: int,
        rv: np.ndarray,
        com_window: bool,
        eclipse_status: bool,
        delta_t: TimeDelta,
    ) -> None:
        """
        Update the Telecom subsystem state based on the new operating mode.

        Parameters:
            old_mode (int): Previous operating mode of the spacecraft.
            new_mode (int): New operating mode of the spacecraft.
            rv (np.ndarray): Position vector of the spacecraft.
            com_window (bool): Indicates if the spacecraft is in a communication window.
            eclipse_status (bool): Indicates if the spacecraft is in eclipse.
            delta_t (TimeDelta): Time step for the update.
        """

        if new_mode == 3:  # UHF_COM

            if old_mode == 4:  # Just passed from x band to uhf
                # We want to prevent the satellite to go back to x-band directly bc of the little GNSS data added
                self.alternating = True

            self.is_communicating = True
            if old_mode != new_mode:  # Just switched to communication mode
                self.com_duration = 0.0 * u.s
                self.t_no_com = 0.0 * u.s
            self.com_duration += delta_t  # Increase communication time

        else:
            self.is_communicating = False
            if new_mode != 4:
                self.t_no_com += (
                    delta_t  # X_BAND mode (4) is considered as communication
                )
            self.com_duration = 0.0 * u.s
            self.alternating = False  # Set back because we re not alternating between uhf-comm and x-band-comm anymore

        # Track vis windows
        if com_window and not self.is_visible:
            self.vis_window_count += 1
            self.is_visible = True
        if not com_window:
            self.is_visible = False

        # SAFE FLAG HANDLING
        # check safe flag triggers (cannot generate a safe flag if already in safe mode)
        if new_mode != 1 and self.safe_flag == False:
            # there might be other safe flag triggers later
            if self.t_no_com > self.t_max_no_com:
                self.safe_flag = True
                self.safe_flag_reason = 1
            if (  # check if in UHF-COM mode + if a safe flag was asked to be triggered by GS
                new_mode == 3
                and old_mode != new_mode
                and not self.alternating
                and (self.vis_window_count in self.uplink_safe_mode.keys())
                and (self.uplink_safe_mode[self.vis_window_count] == True)
            ):
                self.safe_flag = True
                self.safe_flag_reason = 2
                self.vis_window_triggered = self.vis_window_count
                # now, check which kind of resolution is asked
                if self.vis_window_count in self.safe_flag_duration_left_dict.keys():
                    self.safe_flag_duration_left = self.safe_flag_duration_left_dict[
                        self.vis_window_count
                    ]

        # Check safe flag resolution
        if self.safe_flag == True:
            if self.safe_flag_duration_left is not None:
                self.safe_flag_duration_left -= delta_t
            if self.safe_flag_reason == 1:
                if com_window:
                    self.safe_flag = False
                    self.safe_flag_reason = -1
            if self.safe_flag_reason == 2:
                if (
                    self.is_visible
                    and new_mode == 1  # SAFE mode
                    and self.vis_window_count
                    != self.vis_window_triggered  # different vis window
                    and (self.vis_window_count in self.uplink_safe_mode.keys())
                    and (self.uplink_safe_mode[self.vis_window_count] == False)
                ):
                    self.safe_flag = False
                    self.safe_flag_reason = -1
                    self.vis_window_triggered = -1
                elif (
                    self.safe_flag_duration_left is not None
                    and self.safe_flag_duration_left <= 0.0 * u.s
                ):
                    self.safe_flag = False
                    self.safe_flag_reason = -1
                    self.vis_window_triggered = -1
                    self.safe_flag_duration_left = None

    def compute_power_consumed(self, mode: int) -> Quantity["power"]:
        """Compute the power consumed in the specified mode."""
        return self.consumption_mean_uhf[mode] + self.consumption_mean_x_band[mode]

    def compute_data_update(
        self, new_mode: int, delta_t: TimeDelta
    ) -> tuple[Quantity["data quantity"]]:
        """Calculate how much data was sent to ground station during the current timestep.

        Returns:
            tuple which first term is transmited scientific data and second term is transmited housekeeping data. In this case the terms are negative because they are removed from the data storage.
        """
        if new_mode == 4:  # X_BAND
            return (
                -1 * self.x_band_rate * delta_t,
                0 * u.Mbit,
            )  # Second term for HouseKeeping data which is 0 in this case
        elif new_mode == 3:  # UHF
            return (
                0 * u.Mbit,
                -1 * self.uhf_rate * delta_t,
            )  # First term for TOF/GNSS data which is 0 in this case
        else:
            return 0.0 * u.Mbit, 0.0 * u.Mbit

    def __str__(self) -> str:
        """Return a string representation of the Telecom subsystem."""
        strings = "\n".join(
            [
                f"- Communication max duration: {self.com_max_duration}",
                f"- X-band data transmission rate: {self.x_band_rate}",
                f"- Uhf data transmission rate: {self.uhf_rate}",
                f"- Maximum time allowed without communication (if reached, triggers safe mode): {self.t_max_no_com}",
            ]
        )
        return f"Telecom:\n{strings}"

    def raise_safe_flag(self) -> bool:
        """Return true if a safe flag is raised by this subsystem in order to trigger safe mode."""
        return self.safe_flag

    def add_uplink_safe_mode(self, user_input: dict) -> None:
        """Add commands to consider in order to switch to safe mode if asked by the GS. Only called once at initialization."""
        for visibility_window, resolve in user_input.items():
            self.uplink_safe_mode[int(visibility_window)] = True
            if resolve["resolve_type"] == "com_window":
                self.uplink_safe_mode[int(resolve["resolve_value"])] = False
            if resolve["resolve_type"] == "duration":
                self.safe_flag_duration_left_dict[int(visibility_window)] = (
                    float(resolve["resolve_value"]) * u.s
                )

    # Getters
    def get_name(self) -> str:
        return self.name

    def get_telecom_variables(self) -> tuple[Quantity["time"], bool, float]:
        return (
            self.t_no_com,
            self.com_duration,
            self.is_communicating,
            self.alternating,
            self.safe_flag_reason,
            self.safe_flag_duration_left,
            self.is_visible,
        )
