"""Fle for the EPS subsystem.
"""

import copy
from typing import Dict, Tuple

from astropy import units as u
from astropy.time import TimeDelta
from astropy.units import Quantity
import numpy as np

from digital_twin.constants import solar_power
from digital_twin.spacecraft import SubSystem
from digital_twin.spacecraft.payload import Payload
from digital_twin.spacecraft.telecom import Telecom


# To compute energy generated by the solar panels.
class SolarPanel:
    def __init__(self, params: Dict, init_operating_mode: int) -> None:
        print("Initializing the solar panels...")
        self.consumption_mean = {
            int(k): v * u.W for k, v in params["consumption"].items()
        }
        self.mean_solar_input = params["mean_solar_input"] * u.W
        self.nb_cells = params["nb_cells"] * u.one
        self.cell_surface = params["cell_surface"] * (u.m**2)
        self.panels_efficiency = params["efficiency"] * u.one
        self.solar_power = solar_power

        # initialize incident angle
        self.incident_angle = 0 * u.deg
        # TODO: simplification here, always assume incident angle is 0 now (ray come perpendicular to solar panels)

    def compute_power_generated(self, eclipse_status: bool, mode: int) -> Quantity:
        if not eclipse_status:
            return (
                self.get_effective_surface(mode)
                * self.solar_power
                * self.panels_efficiency
            )
        else:
            return 0 * u.W

    def compute_power_consumed(self, mode: int) -> Quantity:
        return self.consumption_mean[mode]

    def get_effective_surface(self, mode: int) -> Quantity:
        if mode == 0 or mode == 2:
            return (
                self.cell_surface
                * self.nb_cells
                * np.cos(np.deg2rad(self.incident_angle.value))
            )
        else:
            incident_angle_random = np.random.rand() * np.pi / 2
            return self.cell_surface * self.nb_cells * np.cos(incident_angle_random)


class Eps(SubSystem):
    def __init__(self, params: Dict, init_operating_mode: int) -> None:
        print("Initializing EPS subsystem... ")

        super(Eps, self).__init__()

        self.consumption_mean = {
            int(k): v * u.W for k, v in params["consumption"].items()
        }

        self.energy = (float(params["total_energy"]) * (u.W * u.hour)).to(u.W * u.s)
        self.min_battery = (float(params["min_battery"]) * (u.W * u.hour)).to(u.W * u.s)
        self.max_battery = (float(params["max_battery"]) * (u.W * u.hour)).to(u.W * u.s)
        self.measure_threshold = (
            float(params["measure_threshold"]) * (u.W * u.hour)
        ).to(u.W * u.s)
        self.com_threshold = (float(params["com_threshold"]) * (u.W * u.hour)).to(
            u.W * u.s
        )
        self.xb_threshold = (float(params["xb_threshold"]) * (u.W * u.hour)).to(
            u.W * u.s
        )

        # initialize battery level to maximum
        self.battery_level = (float(params["total_energy"]) * (u.W * u.hour)).to(
            u.W * u.s
        )

        # initialize solar panels
        self.solar_panels = SolarPanel(params["solar_panels"], init_operating_mode)

        # keep power generated/consumed at last step
        self.power_consumption_last_step = 0.0 * (u.W * u.s)
        self.power_generation_last_step = 0.0 * (u.W * u.s)

    def update(
        self,
        old_mode: str,
        new_mode: str,
        rv: np.ndarray,
        com_window: bool,
        eclipse_status: bool,
        delta_t: TimeDelta,
    ) -> None:
        # TODO: battery thresholds for different modes are dynamic! They are updated at every timestep
        pass

    def update_thresholds(self, telecom: Telecom, payload: Payload) -> None:
        self.update_measure_threshold(telecom, payload)
        self.update_xb_threshold(telecom, payload)
        self.update_com_threshold(telecom, payload)

    def update_measure_threshold(self, telecom: Telecom, payload: Payload) -> None:
        pass

    def update_xb_threshold(self, telecom: Telecom, payload: Payload) -> None:
        pass

    def update_com_threshold(self, telecom: Telecom, payload: Payload) -> None:
        pass

    def compute_power_consumed(self, mode: int) -> Quantity:
        # Add power consumed by the solar panels
        return self.consumption_mean[mode] + self.solar_panels.compute_power_consumed(
            mode
        )

    def update_batteries(
        self, power_consumed: float, delta_t: TimeDelta, eclipse_status: bool, mode: int
    ) -> None:
        # Compute power generated by solar panels
        power_generated = self.solar_panels.compute_power_generated(
            eclipse_status, mode
        )
        # print("consumed:", power_consumed)
        # print("generated:", power_generated)
        # print("eclipse:", eclipse_status)

        self.power_consumption_last_step = power_consumed * delta_t
        self.power_generation_last_step = power_generated * delta_t

        self.battery_level -= power_consumed * delta_t
        self.battery_level += power_generated * delta_t

        # check physical limits
        if self.battery_level > self.energy:  # make sure it doesn't go above
            self.battery_level = copy.deepcopy(
                self.energy
            )  # TODO: check correct way to do
        if self.battery_level < 0.0 * (u.W * u.s):
            self.battery_level = 0.0 * (u.W * u.s)

    def __str__(self) -> str:
        strings = "\n".join(
            [
                f"- min battery threshold: {self.min_battery}",
                f"- max battery threshold: {self.max_battery}",
                f"- measurement threshold: {self.measure_threshold}",
                f"- communication threshold: {self.com_threshold}",
                f"- x-band threshold: {self.xb_threshold}",
            ]
        )
        return f"EPS: \n{strings}"

    def get_battery_energy(self) -> Quantity:
        return self.battery_level

    def get_power_consumption(self) -> Quantity:
        return self.power_consumption_last_step

    def get_power_generation(self) -> Quantity:
        return self.power_generation_last_step
