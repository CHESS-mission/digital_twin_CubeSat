"""Main file for the EPS subsystem
"""

from typing import Dict

import numpy as np

from astropy.time import TimeDelta
from astropy import units as u
from astropy.units import Quantity

from digital_twin.spacecraft import SubSystem

# from digital_twin.spacecraft.eps import SolarPanel


# To compute energy generated by the solar panels.
class SolarPanel:
    def __init__(self, params: Dict, init_operating_mode: int) -> None:
        print("Initializing the solar panels...")
        self.consumption_mean = {
            int(k): v * u.W for k, v in params["consumption"].items()
        }
        print("OKKKKKKKKK")
        self.mean_solar_input = params["mean_solar_input"] * u.W

    def compute_power_generated(self) -> Quantity:
        return self.mean_solar_input

    def compute_power_consumed(self, mode: int):
        return self.consumption_mean[mode]


class Eps(SubSystem):
    def __init__(self, params: Dict, init_operating_mode: int) -> None:
        print("Initializing EPS subsystem... ")

        super(Eps, self).__init__()

        self.consumption_mean = {
            int(k): v * u.W for k, v in params["consumption"].items()
        }

        self.capacity = (float(params["capacity"]) * (u.W * u.hour)).to(u.W * u.s)
        self.min_battery = (float(params["min_battery"]) * (u.W * u.hour)).to(u.W * u.s)
        self.max_battery = (float(params["max_battery"]) * (u.W * u.hour)).to(u.W * u.s)
        self.measure_threshold = (
            float(params["measure_threshold"]) * (u.W * u.hour)
        ).to(u.W * u.s)
        self.com_threshold = (float(params["com_threshold"]) * (u.W * u.hour)).to(
            u.W * u.s
        )
        self.xb_threshold = (float(params["xb_threshold"]) * (u.W * u.hour)).to(
            u.W * u.s
        )

        # initialize battery level to maximum
        self.battery_level = self.max_battery

        # initialize solar panels
        self.solar_panels = SolarPanel(params["solar_panels"], init_operating_mode)

    def update(
        self,
        old_mode: str,
        new_mode: str,
        rv: np.array,
        com_window: bool,
        eclipse_status: bool,
    ) -> None:
        pass

    def compute_power_consumed(self, mode: int) -> float:
        # Add power consumed by the solar panels
        return self.consumption_mean[mode] + self.solar_panels.compute_power_consumed(
            mode
        )

    def update_batteries(self, power_consumed: float, delta_t: TimeDelta) -> float:
        self.battery_level -= power_consumed * delta_t

        # Compute power generated by solar panels (multiply by timestep)
        # TODO: need to make sure it is given in sim_unit of time
        power_generated = self.solar_panels.compute_power_generated() * delta_t.value
        self.battery_level += power_generated

    def __str__(self) -> str:
        strings = "\n".join(
            [
                f"- min battery threshold: {self.min_battery}",
                f"- max battery threshold: {self.max_battery}",
                f"- measurement threshold: {self.measure_threshold}",
                f"- communication threshold: {self.com_threshold}",
                f"- x-band threshold: {self.xb_threshold}",
            ]
        )
        return f"EPS: \n{strings}"
