"""
File for the EPS (Electrical Power Subsystem) implementation.

This module defines the EPS and SolarPanel classes used for managing the spacecraft's 
electrical power system, including the generation, consumption, and management of power. 
It also includes methods for updating thresholds, battery levels, and handling power generation 
depending on the operating mode.

Classes:
    SolarPanel: Represents the solar panel system responsible for power generation.
    Eps: Represents the Electrical Power Subsystem (EPS) for managing power consumption, 
         generation, and battery levels.
"""

import copy
from typing import Optional

from astropy import units as u
from astropy.time import TimeDelta
from astropy.units import Quantity
import numpy as np

from digital_twin.constants import solar_flux
from digital_twin.spacecraft import SubSystem
from digital_twin.spacecraft.payload import Payload
from digital_twin.spacecraft.telecom import Telecom


# To compute energy generated by the solar panels.
class SolarPanel:
    """
    Represent the solar panel system of the spacecraft.

    Attributes:
        name (str): The name of the subsystem.
        consumption_mean (dict[int, Quantity["power"]]): Mean power consumption for different operating modes.
        nb_cells (int): Number of solar cells in the panels.
        cell_surface (Quantity["area"]): Surface area of a single solar cell in square meters (m^2).
        panels_efficiency (float): Efficiency of the solar panels.
        solar_flux (Quantity["irradiance"]): Solar power constant.
    """

    def __init__(self, params: dict, init_operating_mode: int) -> None:
        print("Initializing the solar panels...")
        self.name = "Solar Panel"
        self.consumption_mean = {
            int(k): v * u.W for k, v in params["consumption"].items()
        }
        self.nb_cells = params["nb_cells"]
        self.cell_surface = params["cell_surface"] * (u.m**2)
        self.panels_efficiency = params["efficiency"]
        self.solar_flux = solar_flux

    def compute_power_generated(
        self,
        eclipse_status: bool,
        attitude: int,
        r_earth_sun: Quantity["length"],
        r_earth_sat: Quantity["length"],
        gs_coords: Optional[np.ndarray],
    ) -> Quantity["power"]:
        """
        Calculate the power generated by the solar panels.

        Parameters:
            eclipse_status (bool): True if the spacecraft is in eclipse, False otherwise.
            attitude (int): The spacecraft's attitude mode.
            r_earth_sun (Quantity["length"]): Distance from Earth to the Sun.
            r_earth_sat (Quantity["length"]): Distance from Earth to the spacecraft.
            gs_coords (Optional[np.ndarray]): Ground station coordinates if currently in visibility window, otherwise None.

        Returns:
            Quantity["power"]: The power generated by the solar panels.
        """
        if not eclipse_status:
            return (
                self.get_effective_surface(
                    attitude, r_earth_sun, r_earth_sat, gs_coords
                )
                * self.solar_flux
                * self.panels_efficiency
            )
        else:  # In eclipse, the solar panel don't generate power
            return 0 * u.W

    def compute_power_consumed(self, mode: int) -> Quantity["power"]:
        """Compute the power consumed in the specified mode."""
        return self.consumption_mean[mode]

    def get_effective_surface(
        self,
        attitude: int,
        r_earth_sun: Quantity["length"],
        r_earth_sat: Quantity["length"],
        gs_coords: Optional[np.ndarray],
    ) -> Quantity["area"]:
        """
        Calculate the effective surface area of the solar panels exposed to sunlight.

        Parameters:
            attitude (int): Current spacecraft attitude mode.
            r_earth_sun (Quantity["length"]): Distance from Earth to the Sun.
            r_earth_sat (Quantity["length"]): Distance from Earth to the spacecraft.
            gs_coords (Optional[np.ndarray]): Ground station coordinates if currently in visibility window, otherwise None.

        Returns:
            Quantity["area"]: Effective surface area exposed to sunlight (in square meters).
        """
        if attitude == 1:  # Sun spin => incident angle of 0, no need to calculate it
            incident_angle = 0.0 * u.deg
            intensity = np.cos(np.deg2rad(incident_angle))
            return self.cell_surface * self.nb_cells * intensity
        elif (
            attitude == 0
        ):  # Thomson spin in IDLE => random number between 0 and 0.3 for now
            incident_angle_random = np.random.rand() * np.pi - np.pi / 2
            intensity = np.cos(incident_angle_random) * 0.3
            return self.cell_surface * self.nb_cells * intensity
        elif attitude == 2 or attitude == 4:  # Nadir spin or pointing
            nornal_solar_panels = (
                (r_earth_sat).to(u.km).value
            )  # Direction of normal to solar panels
            r_sat_sun = (r_earth_sun - r_earth_sat).to(u.km).value
            incident_angle = np.arccos(
                np.dot(nornal_solar_panels, r_sat_sun)
                / (np.linalg.norm(nornal_solar_panels) * np.linalg.norm(r_sat_sun))
            )  # Technically not useful to use arccos but good to check incident angle validity
            intensity = np.cos(incident_angle)
            if intensity > 0:  # Means that the incident angle is < 90 deg
                return self.cell_surface * self.nb_cells * intensity
            else:  # Incident angle >= 90 deg => no sunlight
                return 0.0 * (u.m**2)
        else:  # attitude == 3:  # Ground tracking (towards GS)
            nornal_solar_panels = (
                (r_earth_sat - gs_coords).to(u.km).value
            )  # Direction of normal to solar panels
            r_sat_sun = (r_earth_sun - r_earth_sat).to(u.km).value
            incident_angle = np.arccos(
                np.dot(nornal_solar_panels, r_sat_sun)
                / (np.linalg.norm(nornal_solar_panels) * np.linalg.norm(r_sat_sun))
            )  # Technically not useful to use arccos but good to check incident angle validity
            # print(np.rad2deg(incident_angle))
            intensity = np.cos(incident_angle)
            if intensity > 0:  # Means that the incident angle is < 90 deg
                return self.cell_surface * self.nb_cells * intensity
            else:  # Incident angle >= 90 deg => no sunlight
                return 0.0 * (u.m**2)

    def __str__(self) -> str:
        """Return a string representation of the Solar Panels."""
        strings = "\n".join(
            [
                f"   - Number of cells: {self.nb_cells}",
                f"   - Cell surface: {self.cell_surface}",
                f"   - Cell efficiency: {self.panels_efficiency}%",
            ]
        )
        return strings


class Eps(SubSystem):
    """
    Represent the Electrical Power Subsystem (EPS) of the spacecraft.

    Attributes:
        name (str): The name of the subsystem.
        consumption_mean (dict[int, Quantity["power"]]): Mean power consumption for different operating modes.
        energy (Quantity["energy"]): Total energy capacity of the battery.
        min_battery (Quantity["energy"]): Minimum allowable battery level before triggering safe mode.
        max_battery (Quantity["energy"]): Maximum allowable battery level for charging.
        measure_threshold (Quantity["energy"]): Power threshold for measurement mode.
        com_threshold (Quantity["energy"]): Power threshold for communication mode.
        xb_threshold (Quantity["energy"]): Power threshold for X-band transmission mode.
        battery_level (Quantity["energy"]): Current battery energy level.
        solar_panels (SolarPanel): Instance of the SolarPanel class.
        power_consumption_last_step (Quantity["power"]): Power consumed during the last update.
        power_generation_last_step (Quantity["power"]): Power generated during the last update.
        safe_flag (bool): Indicates whether the subsystem is in safe mode.
    """

    def __init__(self, params: dict, init_operating_mode: int) -> None:
        print("Initializing EPS subsystem... ")
        self.name = "EPS"

        super(Eps, self).__init__()

        self.consumption_mean = {
            int(k): v * u.W for k, v in params["consumption"].items()
        }

        self.energy = (float(params["total_energy"]) * (u.W * u.hour)).to(u.W * u.s)
        self.min_battery = (float(params["min_battery"]) * (u.W * u.hour)).to(u.W * u.s)
        self.max_battery = (float(params["max_battery"]) * (u.W * u.hour)).to(u.W * u.s)
        self.measure_threshold = (
            float(params["measure_threshold"]) * (u.W * u.hour)
        ).to(u.W * u.s)
        self.com_threshold = (float(params["com_threshold"]) * (u.W * u.hour)).to(
            u.W * u.s
        )
        self.xb_threshold = (float(params["xb_threshold"]) * (u.W * u.hour)).to(
            u.W * u.s
        )

        # Initialize battery level
        self.battery_level = (float(params["init_battery_level"]) * (u.W * u.hour)).to(
            u.W * u.s
        )

        # Initialize solar panels
        self.solar_panels = SolarPanel(params["solar_panels"], init_operating_mode)

        # In order to store power generated/consumed at last step
        self.power_consumption_last_step = 0.0 * (u.W)
        self.power_generation_last_step = 0.0 * (u.W)

        self.safe_flag = False if params["init_safe_flag"] == "false" else True

    def update(
        self,
        old_mode: int,
        new_mode: int,
        rv: np.ndarray,
        com_window: bool,
        eclipse_status: bool,
        delta_t: TimeDelta,
    ) -> None:
        """
        Update the EPS state, including handling the safe flag.

        Parameters:
            old_mode (int): Previous operating mode of the spacecraft.
            new_mode (int): New operating mode of the spacecraft.
            rv (np.ndarray): Position vector of the spacecraft.
            com_window (bool): Indicate if the spacecraft is in a communication window.
            eclipse_status (bool): Indicate if the spacecraft is in eclipse.
            delta_t (TimeDelta): Timestep for the update.
        """
        # SAFE FLAG HANDLING
        # Check safe flag triggers (cannot generate a safe flag if already in safe mode)
        if new_mode != 1 and self.safe_flag == False:
            if self.battery_level < self.min_battery:
                self.safe_flag = True  # battery_level < battery_min?
        # Check safe flag resolution
        if self.safe_flag == True:
            if self.battery_level >= self.min_battery:
                self.safe_flag = False

    # Currently not used: will be useful when thresholds are updated dynamically
    def update_thresholds(self, telecom: Telecom, payload: Payload) -> None:
        """Function to update different battery thresholds during the simulation."""
        self.update_measure_threshold(telecom, payload)
        self.update_xb_threshold(telecom, payload)
        self.update_com_threshold(telecom, payload)

    def update_measure_threshold(self, telecom: Telecom, payload: Payload) -> None:
        """Function to update the battery threshold for measurement mode."""
        pass

    def update_xb_threshold(self, telecom: Telecom, payload: Payload) -> None:
        """Function to update the battery threshold for x band transmission mode."""
        pass

    def update_com_threshold(self, telecom: Telecom, payload: Payload) -> None:
        """Function to update the battery threshold for uhf communication mode."""
        pass

    def compute_power_consumed(self, mode: int) -> Quantity["power"]:
        """Compute the power consumed in the specified mode."""
        # Add power consumed by the solar panels
        return self.consumption_mean[mode] + self.solar_panels.compute_power_consumed(
            mode
        )

    def update_batteries(
        self,
        power_consumed: Quantity["power"],
        delta_t: TimeDelta,
        eclipse_status: bool,
        attitude: int,
        r_earth_sun: Quantity["length"],
        r_earth_sat: Quantity["length"],
        gs_coords: Optional[np.ndarray],
    ) -> None:
        """Update the battery level based on power consumption and generation."""
        self.battery_level -= power_consumed * delta_t
        self.power_consumption_last_step = power_consumed

        # Only charge if we are not above the battery max threshold (usually 80% of total capacity)
        if self.battery_level < self.max_battery:
            power_generated = self.solar_panels.compute_power_generated(
                eclipse_status, attitude, r_earth_sun, r_earth_sat, gs_coords
            )
            self.battery_level += power_generated * delta_t
            self.power_generation_last_step = power_generated
        else:
            self.power_generation_last_step = 0.0 * (u.W)

        # Check physical limits
        if self.battery_level > self.energy:
            self.battery_level = copy.deepcopy(self.energy)
        if self.battery_level < 0.0 * (u.W * u.s):
            self.battery_level = 0.0 * (u.W * u.s)

    def __str__(self) -> str:
        """Return a string representation of the EPS subsystem."""
        strings = "\n".join(
            [
                f"- min battery threshold: {self.min_battery}",
                f"- max battery threshold: {self.max_battery}",
                f"- measurement threshold: {self.measure_threshold}",
                f"- communication threshold: {self.com_threshold}",
                f"- x-band threshold: {self.xb_threshold}",
            ]
        )
        string_solar_panel = str(self.solar_panels)
        return f"EPS: \n{strings} \n- Solar Panels: \n{string_solar_panel}"

    def raise_safe_flag(self) -> bool:
        """Return true if a safe flag is raised by this subsystem in order to trigger safe mode."""
        return self.safe_flag

    # Getters
    def get_battery_energy(self) -> Quantity["energy"]:
        return self.battery_level

    def get_power_consumption(self) -> Quantity["power"]:
        return self.power_consumption_last_step

    def get_power_generation(self) -> Quantity["power"]:
        return self.power_generation_last_step

    def get_name(self) -> str:
        return self.name
