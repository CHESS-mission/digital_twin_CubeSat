"""Main file for the EPS subsystem
"""

from typing import Dict

import numpy as np

from astropy.time import TimeDelta
from astropy import units as u
from astropy.units import Quantity

from digital_twin.constants import solar_power
from digital_twin.spacecraft import SubSystem
from digital_twin.spacecraft.telecom import Telecom
from digital_twin.spacecraft.payload import Payload

# from digital_twin.spacecraft.eps import SolarPanel


# To compute energy generated by the solar panels.
class SolarPanel:
    def __init__(self, params: Dict, init_operating_mode: int) -> None:
        print("Initializing the solar panels...")
        self.consumption_mean = {
            int(k): v * u.W for k, v in params["consumption"].items()
        }
        self.mean_solar_input = params["mean_solar_input"] * u.W
        self.nb_cells = params["nb_cells"] * u.one
        self.cell_surface = params["cell_surface"] * (u.m**2)
        self.panels_efficiency = params["efficiency"] * u.one
        self.solar_power = solar_power

        # initialize incident angle
        self.incident_angle = 0 * u.deg
        # TODO: simplification here, always assume incident angle is 0 now (ray come perpendicular to solar panels)

    def compute_power_generated(self, eclipse_status: bool) -> Quantity:
        if not eclipse_status:
            return (
                self.get_effective_surface() * self.solar_power * self.panels_efficiency
            )
        else:
            return 0 * u.W

    def compute_power_consumed(self, mode: int) -> Quantity:
        return self.consumption_mean[mode]

    def get_effective_surface(self) -> Quantity:
        return self.cell_surface * self.nb_cells * np.cos(self.incident_angle)


class Eps(SubSystem):
    def __init__(self, params: Dict, init_operating_mode: int) -> None:
        print("Initializing EPS subsystem... ")

        super(Eps, self).__init__()

        self.consumption_mean = {
            int(k): v * u.W for k, v in params["consumption"].items()
        }

        self.capacity = (float(params["capacity"]) * (u.W * u.hour)).to(u.W * u.s)
        self.min_battery = (float(params["min_battery"]) * (u.W * u.hour)).to(u.W * u.s)
        self.max_battery = (float(params["max_battery"]) * (u.W * u.hour)).to(u.W * u.s)
        self.measure_threshold = (
            float(params["measure_threshold"]) * (u.W * u.hour)
        ).to(u.W * u.s)
        self.com_threshold = (float(params["com_threshold"]) * (u.W * u.hour)).to(
            u.W * u.s
        )
        self.xb_threshold = (float(params["xb_threshold"]) * (u.W * u.hour)).to(
            u.W * u.s
        )

        # initialize battery level to maximum
        self.battery_level = self.capacity

        # initialize solar panels
        self.solar_panels = SolarPanel(params["solar_panels"], init_operating_mode)

    def update(
        self,
        old_mode: str,
        new_mode: str,
        rv: np.array,
        com_window: bool,
        eclipse_status: bool,
        delta_t: TimeDelta,
    ) -> None:
        # TODO: battery thresholds for different modes are dynamic! They are updated at every timestep
        pass

    def update_thresholds(self, telecom: Telecom, payload: Payload):
        self.update_measure_threshold(telecom, payload)
        self.update_xb_threshold(telecom, payload)
        self.update_com_threshold(telecom, payload)

    def update_measure_threshold(self, telecom: Telecom, payload: Payload):
        pass

    def update_xb_threshold(self, telecom: Telecom, payload: Payload):
        pass

    def update_com_threshold(self, telecom: Telecom, payload: Payload):
        pass

    def compute_power_consumed(self, mode: int) -> Quantity:
        # Add power consumed by the solar panels
        return self.consumption_mean[mode] + self.solar_panels.compute_power_consumed(
            mode
        )

    def update_batteries(
        self, power_consumed: float, delta_t: TimeDelta, eclipse_status: bool
    ) -> float:
        self.battery_level -= power_consumed * delta_t.value

        # Compute power generated by solar panels (multiply by timestep)
        power_generated = (
            self.solar_panels.compute_power_generated(eclipse_status) * delta_t.value
        )
        self.battery_level += power_generated
        if self.battery_level >= self.capacity:  # make sure it doesn't go above
            self.battery_level = self.capacity  # TODO: check correct way to do

    def __str__(self) -> str:
        strings = "\n".join(
            [
                f"- min battery threshold: {self.min_battery}",
                f"- max battery threshold: {self.max_battery}",
                f"- measurement threshold: {self.measure_threshold}",
                f"- communication threshold: {self.com_threshold}",
                f"- x-band threshold: {self.xb_threshold}",
            ]
        )
        return f"EPS: \n{strings}"
