"""Fle for the EPS subsystem.
"""

import copy
from typing import Dict, Tuple

from astropy import units as u
from astropy.time import TimeDelta
from astropy.units import Quantity
import numpy as np

from digital_twin.constants import solar_power
from digital_twin.spacecraft import SubSystem
from digital_twin.spacecraft.payload import Payload
from digital_twin.spacecraft.telecom import Telecom


# To compute energy generated by the solar panels.
class SolarPanel:
    def __init__(self, params: Dict, init_operating_mode: int) -> None:
        print("Initializing the solar panels...")
        self.name = "Solar Panel"
        self.consumption_mean = {
            int(k): v * u.W for k, v in params["consumption"].items()
        }
        self.nb_cells = params["nb_cells"] * u.one
        self.cell_surface = params["cell_surface"] * (u.m**2)
        self.panels_efficiency = params["efficiency"] * u.one
        self.solar_power = solar_power

    def compute_power_generated(
        self,
        eclipse_status: bool,
        attitude: int,
        r_earth_sun: Quantity,
        r_earth_sat: Quantity,
        gs_coords: Quantity,
    ) -> Quantity:
        if not eclipse_status:
            return (
                self.get_effective_surface(
                    attitude, r_earth_sun, r_earth_sat, gs_coords
                )
                * self.solar_power
                * self.panels_efficiency
            )
        else:
            return 0 * u.W

    def compute_power_consumed(self, mode: int) -> Quantity:
        return self.consumption_mean[mode]

    def get_effective_surface(
        self,
        attitude: int,
        r_earth_sun: Quantity["length"],
        r_earth_sat: Quantity,
        gs_coords: Quantity,
    ) -> Quantity:
        if attitude == 1:  # sun spin => incident angle of 0, no need to calculate it
            incident_angle = 0.0 * u.deg
            intensity = np.cos(np.deg2rad(incident_angle))
            return self.cell_surface * self.nb_cells * intensity
        elif attitude == 0:  # thomson spin => random number between 0 and 0.3 for now
            incident_angle_random = np.random.rand() * np.pi - np.pi / 2
            intensity = np.cos(incident_angle_random) * 0.3
            return self.cell_surface * self.nb_cells * intensity
        elif attitude == 2 or attitude == 4:  # nadir spin or pointing
            nornal_solar_panels = (
                (r_earth_sat).to(u.km).value
            )  # direction of normal to solar panels
            r_sat_sun = (r_earth_sun - r_earth_sat).to(u.km).value
            incident_angle = np.arccos(
                np.dot(nornal_solar_panels, r_sat_sun)
                / (np.linalg.norm(nornal_solar_panels) * np.linalg.norm(r_sat_sun))
            )  # technically not useful to use arccos but good to check incident angle validity
            intensity = np.cos(incident_angle)
            if intensity > 0:  # means that the incident angle is < 90 deg
                return self.cell_surface * self.nb_cells * intensity
            else:  # incident angle >= 90 deg => no sunlight
                return 0.0 * (u.m**2)
        else:  # attitude == 3:  # ground tracking (towards GS)
            nornal_solar_panels = (
                (r_earth_sat - gs_coords).to(u.km).value
            )  # direction of normal to solar panels
            r_sat_sun = (r_earth_sun - r_earth_sat).to(u.km).value
            incident_angle = np.arccos(
                np.dot(nornal_solar_panels, r_sat_sun)
                / (np.linalg.norm(nornal_solar_panels) * np.linalg.norm(r_sat_sun))
            )  # technically not useful to use arccos but good to check incident angle validity
            # print(np.rad2deg(incident_angle))
            intensity = np.cos(incident_angle)
            if intensity > 0:  # means that the incident angle is < 90 deg
                return self.cell_surface * self.nb_cells * intensity
            else:  # incident angle >= 90 deg => no sunlight
                return 0.0 * (u.m**2)


class Eps(SubSystem):
    def __init__(self, params: Dict, init_operating_mode: int) -> None:
        print("Initializing EPS subsystem... ")
        self.name = "EPS"

        super(Eps, self).__init__()

        self.consumption_mean = {
            int(k): v * u.W for k, v in params["consumption"].items()
        }

        self.energy = (float(params["total_energy"]) * (u.W * u.hour)).to(u.W * u.s)
        self.min_battery = (float(params["min_battery"]) * (u.W * u.hour)).to(u.W * u.s)
        self.max_battery = (float(params["max_battery"]) * (u.W * u.hour)).to(u.W * u.s)
        self.measure_threshold = (
            float(params["measure_threshold"]) * (u.W * u.hour)
        ).to(u.W * u.s)
        self.com_threshold = (float(params["com_threshold"]) * (u.W * u.hour)).to(
            u.W * u.s
        )
        self.xb_threshold = (float(params["xb_threshold"]) * (u.W * u.hour)).to(
            u.W * u.s
        )

        # initialize battery level
        self.battery_level = (float(params["init_battery_level"]) * (u.W * u.hour)).to(
            u.W * u.s
        )

        # initialize solar panels
        self.solar_panels = SolarPanel(params["solar_panels"], init_operating_mode)

        # keep power generated/consumed at last step
        self.power_consumption_last_step = 0.0 * (u.W)
        self.power_generation_last_step = 0.0 * (u.W)

        self.safe_flag = False if params["init_safe_flag"] == "false" else True

    def update(
        self,
        old_mode: str,
        new_mode: str,
        rv: np.ndarray,
        com_window: bool,
        eclipse_status: bool,
        delta_t: TimeDelta,
    ) -> None:
        # SAFE FLAG HANDLING
        # check safe flag triggers (cannot generate a safe flag if already in safe mode)
        if new_mode != 1 and self.safe_flag == False:
            if self.battery_level < self.min_battery:
                self.safe_flag = True  # battery_level < battery_min?
        # check safe flag resolution
        if self.safe_flag == True:
            if self.battery_level >= self.min_battery:
                self.safe_flag = False

    def update_thresholds(self, telecom: Telecom, payload: Payload) -> None:
        self.update_measure_threshold(telecom, payload)
        self.update_xb_threshold(telecom, payload)
        self.update_com_threshold(telecom, payload)

    def update_measure_threshold(self, telecom: Telecom, payload: Payload) -> None:
        pass

    def update_xb_threshold(self, telecom: Telecom, payload: Payload) -> None:
        pass

    def update_com_threshold(self, telecom: Telecom, payload: Payload) -> None:
        pass

    def compute_power_consumed(self, mode: int) -> Quantity:
        # Add power consumed by the solar panels
        return self.consumption_mean[mode] + self.solar_panels.compute_power_consumed(
            mode
        )

    def update_batteries(
        self,
        power_consumed: float,
        delta_t: TimeDelta,
        eclipse_status: bool,
        attitude: int,
        r_earth_sun: Quantity,
        r_earth_sat: Quantity,
        gs_coords: Quantity,
    ) -> None:
        # Compute power generated by solar panels

        self.battery_level -= power_consumed * delta_t
        self.power_consumption_last_step = power_consumed

        # only charge if we are not above the battery max threshold (usually 80% of total capacity)
        if self.battery_level < self.max_battery:
            power_generated = self.solar_panels.compute_power_generated(
                eclipse_status, attitude, r_earth_sun, r_earth_sat, gs_coords
            )
            self.battery_level += power_generated * delta_t
            self.power_generation_last_step = power_generated
        else:
            self.power_generation_last_step = 0.0 * (u.W)

        # check physical limits
        if self.battery_level > self.energy:  # make sure it doesn't go above
            self.battery_level = copy.deepcopy(self.energy)
        if self.battery_level < 0.0 * (u.W * u.s):
            self.battery_level = 0.0 * (u.W * u.s)

    def __str__(self) -> str:
        strings = "\n".join(
            [
                f"- min battery threshold: {self.min_battery}",
                f"- max battery threshold: {self.max_battery}",
                f"- measurement threshold: {self.measure_threshold}",
                f"- communication threshold: {self.com_threshold}",
                f"- x-band threshold: {self.xb_threshold}",
            ]
        )
        return f"EPS: \n{strings}"

    def get_battery_energy(self) -> Quantity:
        return self.battery_level

    def get_power_consumption(self) -> Quantity:
        return self.power_consumption_last_step

    def get_power_generation(self) -> Quantity:
        return self.power_generation_last_step

    def raise_safe_flag(self) -> bool:
        return self.safe_flag

    def get_name(self) -> str:
        return self.name
